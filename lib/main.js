// Generated by CoffeeScript 1.9.1
(function() {
  var CND, _copy, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    slice1 = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOTMETAL';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);


  /* TAINT should use a (CND?) libary method for these */

  this.HTML = Object.defineProperty(this, 'HTML', {
    get: function() {
      return require('./HTML');
    }
  });

  this.HYPHENATOR = Object.defineProperty(this, 'HYPHENATOR', {
    get: function() {
      return require('./HYPHENATOR');
    }
  });

  this.LINEBREAKER = Object.defineProperty(this, 'LINEBREAKER', {
    get: function() {
      return require('./LINEBREAKER');
    }
  });

  this.MARKDOWN = Object.defineProperty(this, 'MARKDOWN', {
    get: function() {
      return require('./MARKDOWN');
    }
  });

  this.TYPO = Object.defineProperty(this, 'TYPO', {
    get: function() {
      return require('./TYPO');
    }
  });

  this.rpr = function(me) {
    var R, Rc, Ro, Rt, chunk, close_tags, content, i, idx, j, k, len, len1, len2, open_tags, t;
    R = [];
    for (idx = i = 0, len = me.length; i < len; idx = ++i) {
      chunk = me[idx];
      open_tags = chunk[0], content = chunk[1], close_tags = chunk[2];
      R.push([Ro = [], Rt = [], Rc = []]);
      for (j = 0, len1 = open_tags.length; j < len1; j++) {
        t = open_tags[j];
        Ro.push(this._render_open_tag.apply(this, t));
      }
      Rt.push(CND.isa_list(content) ? this._render_open_tag.apply(this, content) : content);
      for (k = 0, len2 = close_tags.length; k < len2; k++) {
        t = close_tags[k];
        Rc.push(this._render_close_tag(t));
      }
    }
    return '\n' + CND.columnify(R, {
      paddingChr: '_'
    });
  };

  this.as_html = function(me, replace_shy) {
    var R, chunk, close_tags, i, idx, j, k, len, len1, len2, open_tags, t, text;
    if (replace_shy == null) {
      replace_shy = true;
    }
    R = [];
    for (idx = i = 0, len = me.length; i < len; idx = ++i) {
      chunk = me[idx];
      open_tags = chunk[0], text = chunk[1], close_tags = chunk[2];
      for (j = 0, len1 = open_tags.length; j < len1; j++) {
        t = open_tags[j];
        R.push(this._render_open_tag.apply(this, t));
      }
      R.push(this._correct_text(me, chunk, idx, replace_shy));
      for (k = 0, len2 = close_tags.length; k < len2; k++) {
        t = close_tags[k];
        R.push(this._render_close_tag(t));
      }
    }
    return R.join('');
  };

  this._correct_text = function(me, chunk, idx, replace_shy) {
    var R, close_tags, content, is_last, open_tags;
    open_tags = chunk[0], content = chunk[1], close_tags = chunk[2];
    if (CND.isa_list(content)) {
      return this._render_open_tag.apply(this, content);
    }
    is_last = idx === me.length - 1;
    R = content;
    if (replace_shy) {
      R = R.replace(/\xad$/, is_last ? '-' : '');
    }
    if (is_last) {
      R = R.replace(/\s+$/, '');
    }
    return R;
  };

  this._render_open_tag = function(name, attributes) {

    /* TAINT inefficient */
    return (this._render_empty_tag(name, attributes)).replace(/<\/[^>]+>$/, '');
  };

  this._render_close_tag = function(name) {
    return "</" + name + ">";
  };

  this._render_as_close_tag = function(open_tag) {

    /* TAINT inefficient */
    return this._render_close_tag(open_tag.replace(/^<([^\s>]+).*$/, '$1'));
  };

  this._render_empty_tag = function(name, attributes) {

    /* TAINT should remove dependency on teacup */
    var TEACUP;
    TEACUP = require('coffeenode-teacup');
    return TEACUP.render((function(_this) {
      return function() {
        if (attributes != null) {
          return TEACUP.TAG(name, attributes);
        }
      };
    })(this));
    return TEACUP.render((function(_this) {
      return function() {
        return TEACUP.TAG(name);
      };
    })(this));
  };

  this._new_hotml = function() {
    return [];
  };

  this._new_chunk = function() {
    return [[], '', []];
  };

  this.add = function() {
    var me, tail, target, type;
    me = arguments[0], type = arguments[1], tail = 3 <= arguments.length ? slice1.call(arguments, 2) : [];

    /* TAINT ??? won't work correctly with empty tags because we check for `text.length == 0` ??? */
    if (me.length === 0) {
      me.push(this._new_chunk());
    }
    target = CND.last_of(me);
    switch (type) {
      case 'open-tag':
      case 'lone-tag':
      case 'text':
        if (target[1].length > 0 || target[2].length > 0) {
          me.push(target = this._new_chunk());
        }
        break;
      default:
        null;
    }
    switch (type) {
      case 'open-tag':
        target[0].push(tail);
        break;
      case 'lone-tag':
        target[1] = tail;
        break;
      case 'lone-tag':
      case 'text':
        target[1] = tail[0];
        break;
      case 'close-tag':
        target[2].push(tail[0]);
        break;
      case 'comment':
      case 'doctype':
        null;
        break;
      default:
        throw new Error("unknown type " + (rpr(type)));
    }
    return me;
  };

  this.TAG = {};

  this.TAG.add_class = (function(_this) {
    return function(tag, clasz) {

      /* Add a CSS class. */
      var attributes, old_class;
      attributes = tag[1];
      if ((old_class = attributes['class']) != null) {
        if ((old_class.indexOf(clasz)) >= 0) {
          return tag;
        }
        attributes['class'] += ' ' + clasz;
      } else {
        attributes['class'] = clasz;
      }
      return tag;
    };
  })(this);

  this.TAG.remove_class = (function(_this) {
    return function(tag, clasz) {

      /* Remove a CSS class. */
      var attributes, old_class, position;
      attributes = tag[1];
      if ((old_class = attributes['class']) == null) {
        return tag;
      }
      if ((position = old_class.indexOf(clasz)) < 0) {
        return tag;
      }
      if (old_class.length === clasz.length) {
        _this.TAG.remove(tag, 'class');
      } else {
        attributes['class'] = (old_class.slice(0, position) + old_class.slice(position + clasz.length)).trim();
      }
      return tag;
    };
  })(this);

  this.TAG.get = (function(_this) {
    return function(tag, name) {

      /* Get an attribute value. */
      return tag[1][name];
    };
  })(this);

  this.TAG.set = (function(_this) {
    return function(tag, name, value) {
      if (value == null) {
        value = void 0;
      }

      /* Set an attribute. */
      tag[1][name] = value;
      return tag;
    };
  })(this);

  this.TAG.remove = (function(_this) {
    return function(tag, name) {

      /* Remove an attribute. */
      delete tag[1][name];
      return tag;
    };
  })(this);

  _copy = function(x) {
    return JSON.parse(JSON.stringify(x));
  };

  this.slice = function(me, start, stop) {
    var R, close_tag, close_tags, first_open_tags, i, idx, j, k, l, last_close_tags, len, len1, len2, m, main_idx, n, open_tag, open_tag_count, open_tags, ref, ref1, ref2, ref3, ref4, sub_idx, tag_stack, text;
    if (start == null) {
      start = 0;
    }
    if (stop == null) {
      stop = null;
    }
    if (stop == null) {
      stop = me.length;
    }
    start = Math.max(0, Math.min(me.length, start));
    stop = Math.max(0, Math.min(me.length, stop));
    if (start >= stop) {
      return [];
    }
    R = _copy(me);
    if (start === 0 && stop === me.length) {
      return R;
    }
    R = R.slice(start, stop);
    open_tag_count = 0;
    first_open_tags = R[0][0];
    last_close_tags = R[R.length - 1][2];
    tag_stack = [];

    /* Walking backwards from `start` to the beginning, collecting closing and opening tags: */
    for (main_idx = i = ref = start - 1; i >= 0; main_idx = i += -1) {
      ref1 = me[main_idx], open_tags = ref1[0], text = ref1[1], close_tags = ref1[2];
      open_tag_count -= close_tags.length;
      for (sub_idx = j = ref2 = open_tags.length - 1; j >= 0; sub_idx = j += -1) {
        open_tag_count += 1;
        if (!(open_tag_count > 0)) {
          continue;
        }
        first_open_tags.unshift(_copy(open_tags[sub_idx]));
      }
    }

    /* Closing all remaining open tags: */
    for (k = 0, len = R.length; k < len; k++) {
      ref3 = R[k], open_tags = ref3[0], text = ref3[1], close_tags = ref3[2];
      for (l = 0, len1 = open_tags.length; l < len1; l++) {
        open_tag = open_tags[l];
        tag_stack.push(open_tag[0]);
      }
      for (m = 0, len2 = close_tags.length; m < len2; m++) {
        close_tag = close_tags[m];
        tag_stack.pop();
      }
    }
    for (idx = n = ref4 = tag_stack.length - 1; n >= 0; idx = n += -1) {
      last_close_tags.push(tag_stack[idx]);
    }
    return R;
  };

  this.slice_toplevel_tags = function(me, handler) {
    var R, chunk, chunk_idx, close_tags, error, i, last_open_tag_count, len, open_tag_count, open_tags, slice, start, stop, text;
    if (handler == null) {
      handler = null;
    }

    /* TAINT make ignorable inter-tag WS configurable? */
    open_tag_count = 0;
    last_open_tag_count = 0;
    start = null;
    stop = null;
    R = handler != null ? null : [];
    for (chunk_idx = i = 0, len = me.length; i < len; chunk_idx = ++i) {
      chunk = me[chunk_idx];
      open_tags = chunk[0], text = chunk[1], close_tags = chunk[2];
      if (open_tag_count === 0) {
        if (open_tags.length === 0) {
          if (!/^\s*$/.test(text)) {
            error = new Error("invalid HoTMetaL structure: detected printing material between toplevel tags");
            if (handler != null) {
              return handler(error);
            } else {
              throw error;
            }
          }
        } else {
          start = chunk_idx;
        }
      }
      open_tag_count += +open_tags.length;
      open_tag_count += -close_tags.length;
      if (open_tag_count === 0) {
        if (open_tags.length > 0 || last_open_tag_count !== 0) {
          stop = chunk_idx + 1;
          slice = this.slice(me, start, stop);
          if (handler != null) {
            handler(null, slice);
          } else {
            R.push(slice);
          }
        }
      } else if (open_tag_count < 0) {
        error = new Error("invalid HoTMetaL structure");
        if (handler != null) {
          return handler(error);
        } else {
          throw error;
        }
      }
      last_open_tag_count = open_tag_count;
    }
    return R;
  };

  this.is_wrapped = function(me) {
    var chunk_idx, close_tag_name, close_tags, i, is_last_chunk, is_last_tag, j, k, last_chunk_idx, last_tag_idx, len, len1, len2, open_tag, open_tag_name, open_tags, ref, tag_idx, tag_stack, text;
    tag_stack = [];
    last_chunk_idx = me.length - 1;

    /* TAINT use library method */
    for (chunk_idx = i = 0, len = me.length; i < len; chunk_idx = ++i) {
      ref = me[chunk_idx], open_tags = ref[0], text = ref[1], close_tags = ref[2];
      if (chunk_idx === 0 && open_tags.length === 0) {
        return false;
      }
      is_last_chunk = chunk_idx === last_chunk_idx;
      last_tag_idx = close_tags.length - 1;
      for (j = 0, len1 = open_tags.length; j < len1; j++) {
        open_tag = open_tags[j];
        tag_stack.push(open_tag[0]);
      }
      for (tag_idx = k = 0, len2 = close_tags.length; k < len2; tag_idx = ++k) {
        close_tag_name = close_tags[tag_idx];
        is_last_tag = is_last_chunk && tag_idx === last_tag_idx;
        open_tag_name = tag_stack.pop();
        if (open_tag_name !== close_tag_name) {
          throw new Error("unbalanced tags: " + (rpr(open_tag_name)) + " isnt " + (rpr(close_tag_name)));
        }
        if (tag_stack.length === 0) {
          return is_last_tag;
        }
      }
    }
    return false;
  };

  this.unwrap = function(me, silent) {
    if (silent == null) {
      silent = false;
    }
    if (this.is_wrapped(me)) {
      (CND.first_of(me))[0].shift();
      (CND.last_of(me))[2].pop();
    } else if (!silent) {
      throw new Error("HTML does not form a wrapped structure");
    }
    return me;
  };

}).call(this);
