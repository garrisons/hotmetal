// Generated by CoffeeScript 1.9.0
(function() {
  var CND, TEACUP, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOTMETAL';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  TEACUP = require('coffeenode-teacup');

  this.rpr = function(me) {
    var R, Rc, Ro, Rt, chunk, close_tags, content, idx, open_tags, t, _i, _j, _k, _len, _len1, _len2;
    R = [];
    for (idx = _i = 0, _len = me.length; _i < _len; idx = ++_i) {
      chunk = me[idx];
      open_tags = chunk[0], content = chunk[1], close_tags = chunk[2];
      R.push([Ro = [], Rt = [], Rc = []]);
      for (_j = 0, _len1 = open_tags.length; _j < _len1; _j++) {
        t = open_tags[_j];
        Ro.push(this._render_open_tag.apply(this, t));
      }
      Rt.push(CND.isa_list(content) ? this._render_open_tag.apply(this, content) : content);
      for (_k = 0, _len2 = close_tags.length; _k < _len2; _k++) {
        t = close_tags[_k];
        Rc.push(this._render_close_tag(t));
      }
    }
    return '\n' + CND.columnify(R, {
      paddingChr: '_'
    });
  };

  this.as_html = function(me) {
    var R, chunk, close_tags, idx, open_tags, t, text, _i, _j, _k, _len, _len1, _len2;
    R = [];
    for (idx = _i = 0, _len = me.length; _i < _len; idx = ++_i) {
      chunk = me[idx];
      open_tags = chunk[0], text = chunk[1], close_tags = chunk[2];
      for (_j = 0, _len1 = open_tags.length; _j < _len1; _j++) {
        t = open_tags[_j];
        R.push(this._render_open_tag.apply(this, t));
      }
      R.push(this._correct_text(me, chunk, idx));
      for (_k = 0, _len2 = close_tags.length; _k < _len2; _k++) {
        t = close_tags[_k];
        R.push(this._render_close_tag(t));
      }
    }
    return R.join('');
  };

  this._correct_text = function(me, chunk, idx) {
    var R, close_tags, content, is_last, open_tags;
    open_tags = chunk[0], content = chunk[1], close_tags = chunk[2];
    if (CND.isa_list(content)) {
      return this._render_open_tag.apply(this, content);
    }
    is_last = idx === me.length - 1;
    R = content;
    R = R.replace(/\xad$/, is_last ? '-' : '');
    if (is_last) {
      R = R.replace(/\s+$/, '');
    }
    return R;
  };

  this._render_open_tag = function(name, attributes) {
    return (this._render_empty_tag(name, attributes)).replace(/<\/[^>]+>$/, '');
  };

  this._render_close_tag = function(name) {
    return "</" + name + ">";
  };

  this._render_as_close_tag = function(open_tag) {
    return this._render_close_tag(open_tag.replace(/^<([^\s>]+).*$/, '$1'));
  };

  this._render_empty_tag = function(name, attributes) {
    return TEACUP.render((function(_this) {
      return function() {
        return TEACUP.TAG(name, attributes);
      };
    })(this));
  };

  this._new_hotml = function() {
    return [];
  };

  this._new_chunk = function() {
    return [[], '', []];
  };

  this.add = function() {
    var me, tail, target, type;
    me = arguments[0], type = arguments[1], tail = 3 <= arguments.length ? __slice.call(arguments, 2) : [];

    /* TAINT ??? won't work correctly with empty tags because we check for `text.length == 0` ??? */
    if (me.length === 0) {
      me.push(this._new_chunk());
    }
    target = CND.last_of(me);
    switch (type) {
      case 'open-tag':
      case 'lone-tag':
      case 'text':
        if (target[1].length > 0 || target[2].length > 0) {
          me.push(target = this._new_chunk());
        }
        break;
      default:
        null;
    }
    switch (type) {
      case 'open-tag':
        target[0].push(tail);
        break;
      case 'lone-tag':
        target[1] = tail;
        break;
      case 'lone-tag':
      case 'text':
        target[1] = tail[0];
        break;
      case 'close-tag':
        target[2].push(tail[0]);
        break;
      case 'comment':
      case 'doctype':
        null;
        break;
      default:
        throw new Error("unknown type " + (rpr(type)));
    }
    return me;
  };

  this.copy = function(me) {
    var chunk, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = me.length; _i < _len; _i++) {
      chunk = me[_i];
      _results.push([chunk[0].slice(0), chunk[1], chunk[2].slice(0)]);
    }
    return _results;
  };

  this.TAG = {};

  this.TAG.add_class = (function(_this) {
    return function(tag, clasz) {
      var attributes;
      attributes = tag[1];
      if (attributes['class'] != null) {
        attributes['class'] += ' ' + clasz;
      } else {
        attributes['class'] = clasz;
      }
      return tag;
    };
  })(this);

  this.slice = function(me, start, stop) {
    var R, close_tag, close_tags, first_open_tags, idx, last_close_tags, main_idx, open_tag, open_tag_count, open_tags, sub_idx, tag_stack, text, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4;
    if (start == null) {
      start = 0;
    }
    if (stop == null) {
      stop = null;
    }
    if (stop == null) {
      stop = me.length;
    }
    start = Math.max(0, Math.min(me.length, start));
    stop = Math.max(0, Math.min(me.length, stop));
    if (start >= stop) {
      return [];
    }
    R = this.copy(me);
    if (start === 0 && stop === me.length) {
      return R;
    }
    R = R.slice(start, stop);
    open_tag_count = 0;
    first_open_tags = R[0][0];
    last_close_tags = R[R.length - 1][2];
    tag_stack = [];

    /* Walking backwards from `start` to the beginning, collecting closing and opening tags: */
    for (main_idx = _i = _ref = start - 1; _i >= 0; main_idx = _i += -1) {
      _ref1 = me[main_idx], open_tags = _ref1[0], text = _ref1[1], close_tags = _ref1[2];
      open_tag_count -= close_tags.length;
      for (sub_idx = _j = _ref2 = open_tags.length - 1; _j >= 0; sub_idx = _j += -1) {
        open_tag_count += 1;
        if (!(open_tag_count > 0)) {
          continue;
        }
        first_open_tags.unshift(open_tags[sub_idx]);
      }
    }

    /* Closing all remaining open tags: */
    for (_k = 0, _len = R.length; _k < _len; _k++) {
      _ref3 = R[_k], open_tags = _ref3[0], text = _ref3[1], close_tags = _ref3[2];
      for (_l = 0, _len1 = open_tags.length; _l < _len1; _l++) {
        open_tag = open_tags[_l];
        tag_stack.push(open_tag[0]);
      }
      for (_m = 0, _len2 = close_tags.length; _m < _len2; _m++) {
        close_tag = close_tags[_m];
        tag_stack.pop();
      }
    }
    for (idx = _n = _ref4 = tag_stack.length - 1; _n >= 0; idx = _n += -1) {
      last_close_tags.push(tag_stack[idx]);
    }
    return R;
  };

  this.slice_toplevel_tags = function(me, handler) {
    var R, chunk, chunk_idx, close_tags, error, last_open_tag_count, open_tag_count, open_tags, slice, start, stop, text, _i, _len;
    if (handler == null) {
      handler = null;
    }

    /* TAINT make ignorable inter-tag WS configurable? */
    open_tag_count = 0;
    last_open_tag_count = 0;
    start = null;
    stop = null;
    R = handler != null ? null : [];
    for (chunk_idx = _i = 0, _len = me.length; _i < _len; chunk_idx = ++_i) {
      chunk = me[chunk_idx];
      open_tags = chunk[0], text = chunk[1], close_tags = chunk[2];
      if (open_tag_count === 0) {
        if (open_tags.length === 0) {
          if (!/^\s*$/.test(text)) {
            error = new Error("invalid HoTMetaL structure: detected printing material between toplevel tags");
            if (handler != null) {
              return handler(error);
            } else {
              throw error;
            }
          }
        } else {
          start = chunk_idx;
        }
      }
      open_tag_count += open_tags.length;
      open_tag_count -= close_tags.length;
      if (open_tag_count === 0) {
        if (last_open_tag_count !== 0) {
          stop = chunk_idx + 1;
          slice = this.slice(me, start, stop);
          if (handler != null) {
            handler(null, slice);
          } else {
            R.push(slice);
          }
        }
      } else if (open_tag_count < 0) {
        error = new Error("invalid HoTMetaL structure");
        if (handler != null) {
          return handler(error);
        } else {
          throw error;
        }
      }
      last_open_tag_count = open_tag_count;
    }
    return R;
  };

  this.is_wrapped = function(me) {
    var chunk_idx, close_tag_name, close_tags, is_last_chunk, is_last_tag, last_chunk_idx, last_tag_idx, open_tag, open_tag_name, open_tags, tag_idx, tag_stack, text, _i, _j, _k, _len, _len1, _len2, _ref;
    tag_stack = [];
    last_chunk_idx = me.length - 1;

    /* TAINT use library method */
    for (chunk_idx = _i = 0, _len = me.length; _i < _len; chunk_idx = ++_i) {
      _ref = me[chunk_idx], open_tags = _ref[0], text = _ref[1], close_tags = _ref[2];
      if (chunk_idx === 0 && open_tags.length === 0) {
        return false;
      }
      is_last_chunk = chunk_idx === last_chunk_idx;
      last_tag_idx = close_tags.length - 1;
      for (_j = 0, _len1 = open_tags.length; _j < _len1; _j++) {
        open_tag = open_tags[_j];
        tag_stack.push(open_tag[0]);
      }
      for (tag_idx = _k = 0, _len2 = close_tags.length; _k < _len2; tag_idx = ++_k) {
        close_tag_name = close_tags[tag_idx];
        is_last_tag = is_last_chunk && tag_idx === last_tag_idx;
        open_tag_name = tag_stack.pop();
        if (open_tag_name !== close_tag_name) {
          throw new Error("unbalanced tags: " + (rpr(open_tag_name)) + " isnt " + (rpr(close_tag_name)));
        }
        if (tag_stack.length === 0) {
          return is_last_tag;
        }
      }
    }
    return false;
  };

  this.unwrap = function(me, silent) {
    if (silent == null) {
      silent = false;
    }
    if (this.is_wrapped(me)) {
      (CND.first_of(me))[0].shift();
      (CND.last_of(me))[2].pop();
    } else if (!silent) {
      throw new Error("HTML does not form a wrapped structure");
    }
    return me;
  };


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  this.break_lines = function(me, test_line) {
    var fits, is_first_line, is_first_try, is_last_line, last_slice, slice, start, stop;
    start = 0;
    stop = start;
    last_slice = null;
    slice = null;
    is_first_line = true;
    is_last_line = false;
    is_first_try = true;
    while (true) {
      stop += 1;
      is_last_line = (stop > me.length) || (stop - start === 0 && stop === me.length);
      if (is_last_line) {
        if (last_slice != null) {
          test_line('set', last_slice, is_first_line, is_last_line);
        } else if (slice != null) {
          test_line('set', slice, is_first_line, is_last_line);
        }
        return null;
      }
      slice = this.slice(me, start, stop);
      fits = test_line('test', slice, is_first_line, is_last_line);
      if (fits) {
        last_slice = slice;
      } else {
        if (last_slice != null) {
          test_line('set', last_slice, is_first_line, is_last_line);
          last_slice = null;
          start = stop - 1;
          stop = start;
        } else {
          test_line('set', slice, is_first_line, is_last_line);
          slice = null;
          start = stop;
          stop = start;
        }
        is_first_line = false;
      }
    }
    throw new Error("should never happen");
  };

  this.fragmentize = function(text, settings) {
    var R, breakpoint, extended, incremental, last_position, line_breaker, part, position, required, _ref, _ref1;
    text = text.replace(/\n/g, ' ');
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    extended = (_ref1 = settings != null ? settings['extended'] : void 0) != null ? _ref1 : false;
    line_breaker = new (require('linebreak'))(text);
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      position = breakpoint.position, required = breakpoint.required;
      if (incremental && (last_position != null)) {
        part = text.slice(last_position, breakpoint.position);
      } else {
        part = text.slice(0, breakpoint.position);
      }
      last_position = position;
      R.push(extended ? [part, required, position] : part);
    }
    return R;
  };

  this.new_hyphenate = function(hyphenation, min_length) {
    var HYPHER, Hypher;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 2;
    }

    /* https://github.com/bramstein/hypher */
    Hypher = require('hypher');
    if (hyphenation == null) {
      hyphenation = require('hyphenation.en-us');
    }
    HYPHER = new Hypher(hyphenation);
    return HYPHER.hyphenateText.bind(HYPHER);
  };

  this.TYPO = {};

  this.TYPO.quotes = (function(_this) {
    return function(text) {
      return (require('typogr')).smartypants(text);
    };
  })(this);

  this.TYPO.dashes = (function(_this) {
    return function(text) {
      return (require('typogr')).smartypants(text);
    };
  })(this);

  this.MD = {};

  this.MD.new_parser = (function(_this) {
    return function(settings) {
      var MarkdownIt;
      if (settings != null) {
        throw new Error("settings not yet supported");
      }
      settings = {
        html: true,
        linkify: false,
        breaks: false,
        langPrefix: 'codelang-',
        typographer: true,
        quotes: '“”‘’'
      };
      MarkdownIt = require('markdown-it');
      return new MarkdownIt(settings);
    };
  })(this);

  this.MD.as_html = (function(_this) {
    return function(md, parser) {
      if (parser == null) {
        parser = null;
      }
      return (parser != null ? parser : _this.MD.new_parser()).render(md);
    };
  })(this);

  this.HTML = {};

  this.HTML.parse = (function(_this) {
    return function(html, disperse, hyphenation) {
      var R, fragmentize, handlers, hyphenate, lone_tags, parser;
      if (disperse == null) {
        disperse = true;
      }
      if (hyphenation == null) {
        hyphenation = true;
      }

      /* TAINT words in code blocks will be hyphenated, too */
      lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);
      if (disperse) {
        fragmentize = _this.fragmentize.bind(_this);
        if (hyphenation === false) {
          hyphenate = function(text) {
            return text;
          };
        } else if (CND.isa_function(hyphenation)) {
          hyphenate = hyphenation;
        } else {
          hyphenation = hyphenation === true ? null : hyphenation;
          hyphenate = _this.new_hyphenate(hyphenation);
        }
      } else {
        fragmentize = function(text) {
          return [text];
        };
        hyphenate = function(text) {
          return text;
        };
      }
      handlers = {
        doctype: function(name, pid, sid) {
          return _this.add(R, 'doctype', name, pid, sid);
        },
        endTag: function(name) {
          return _this.add(R, 'close-tag', name);
        },
        comment: function(text) {
          return _this.add(R, 'comment', CND.escape_html(text));
        },
        text: function(text) {
          var text_part, _i, _len, _ref, _results;
          text = CND.escape_html(text);
          text = hyphenate(text);
          _ref = fragmentize(text);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            text_part = _ref[_i];
            _results.push(_this.add(R, 'text', text_part));
          }
          return _results;
        },
        startTag: function(name, a) {
          var attributes, k, v, _i, _len, _ref;
          attributes = {};
          if (a != null) {
            for (_i = 0, _len = a.length; _i < _len; _i++) {
              _ref = a[_i], k = _ref.name, v = _ref.value;
              attributes[k] = v;
            }
          }
          if (__indexOf.call(lone_tags, name) >= 0) {
            if (name === 'wbr') {
              if ((Object.keys(attributes)).length > 0) {
                throw new Error("illegal <wbr> tag with attributes");
              }

              /* as per https://developer.mozilla.org/en/docs/Web/HTML/Element/wbr */
              return _this.add(R, 'text', '\u200b');
            } else {
              return _this.add(R, 'lone-tag', name, attributes);
            }
          } else {
            return _this.add(R, 'open-tag', name, attributes);
          }
        }
      };
      parser = new (require('parse5')).SimpleApiParser(handlers);
      R = _this._new_hotml();
      parser.parse(html);
      return R;
    };
  })(this);


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  this.get_column_linecounts = function(strategy, line_count, column_count) {

    /* thx to http://stackoverflow.com/a/1244369/256361 */
    var R, col, _i;
    R = [];
    switch (strategy) {
      case 'even':
        for (col = _i = 1; 1 <= column_count ? _i <= column_count : _i >= column_count; col = 1 <= column_count ? ++_i : --_i) {
          R.push(Math.floor((line_count + column_count - col) / column_count));
        }
        break;
      default:
        throw new Error("unknown strategy " + (rpr(strategy)));
    }
    return R;
  };

  this.demo = function() {
    var H, html;
    H = this;
    html = "Paragraph internationalization assignment (certainly) relativity.";
    html = "https://github.com/devongovett/linebreak";
    html = "中國皇帝北京上海香港";
    html = "볍쌀(영어: rice) 또는 쌀은 벼의 씨앗에서 껍질을 벗겨 낸 식량이다. 그(도정을 한) 정도에 따라, 왕겨만 살짝 벗겨내면 현미(매조미쌀, 핍쌀)가 되고, 곱게 쓿으면 흰쌀(아주먹이)이 된다. 밥이나 떡을 해서 먹으며, 식혜같은 음료나 소주, 청주 등 술의 원료가 된다.";
    html = "ข้าวเป็นธัญพืชซึ่งประชากรโลกบริโภคเป็นอาหารสำคัญ โดยเฉพาะอย่างยิ่งในทวีปเอเชีย จากข้อมูลเมื่อปี";
    html = "རྩོམ་ཡིག་འདི་ཆ་མི་ཚང་བས་རྩོམ་ཡིག་འདི་ཆ་ཚང་བོར་བཟོས་ནས་ཝེ་ཁེ་རིག་མཛོད་གོང་འཕེལ་གཏོང་རོགས།";
    html = "Lo <div id='mydiv'><em><i>arcade &amp; &#x4e00; illustration <img src='x.jpg'>\n<b>bromance</b> cyberspace <span class='foo'></span> necessarily</i></em> completely.</div>";
    return H.parse(html, (function(_this) {
      return function(error, hotml) {
        var delta, start, stop, _i, _j, _len, _ref;
        if (error != null) {
          throw error;
        }
        _ref = [0, 3, 10];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          start = _ref[_i];
          for (delta = _j = 0; _j <= 15; delta = ++_j) {
            stop = start + delta;
            info(start, stop, H.as_html(H.slice(hotml, start, stop)));
          }
        }
        urge(JSON.stringify(hotml));
        help(H.rpr(hotml));
        return info(H.as_html(hotml));
      };
    })(this));
  };

  if (module.parent == null) {
    this.demo();
  }

}).call(this);
