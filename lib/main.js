// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, D, TEACUP, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    __slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'scratch';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  TEACUP = require('coffeenode-teacup');

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  this.rpr = function(me) {
    return '\n' + CND.columnify(me, {
      paddingChr: '_'
    });
  };

  this.as_html = function(me) {
    var R, idx, list_of_close_tags, list_of_open_tags, t, text, texts, _, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    R = [];
    list_of_open_tags = me[0], _ = me[1], list_of_close_tags = me[2];
    texts = this._get_corrected_texts(me);
    for (idx = _i = 0, _len = texts.length; _i < _len; idx = ++_i) {
      text = texts[idx];
      _ref = list_of_open_tags[idx];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        t = _ref[_j];
        R.push(t);
      }
      R.push(text);
      _ref1 = list_of_close_tags[idx];
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        t = _ref1[_k];
        R.push(t);
      }
    }
    return R.join('');
  };

  this._get_corrected_texts = function(me) {
    var R, first_idx, idx, last_idx, list_of_close_tags, list_of_open_tags, shy_replacement, text, texts, _i, _j, _len, _len1;
    list_of_open_tags = me[0], texts = me[1], list_of_close_tags = me[2];
    R = [];
    first_idx = +Infinity;
    last_idx = -Infinity;
    for (idx = _i = 0, _len = texts.length; _i < _len; idx = ++_i) {
      text = texts[idx];
      if (text.length > 0 && text[0] !== '<') {
        first_idx = Math.min(idx, first_idx);
        last_idx = Math.max(idx, last_idx);
      }
    }
    for (idx = _j = 0, _len1 = texts.length; _j < _len1; idx = ++_j) {
      text = texts[idx];
      if (text.length > 0 && text[0] !== '<') {
        shy_replacement = idx === last_idx ? '-' : '';
        text = text.replace(/\xad$/, shy_replacement);
        if (idx === last_idx) {
          text = text.replace(/\s+$/, '');
        }
        text = text.replace(/&/g, '&amp;');
        text = text.replace(/</g, '&lt;');
        text = text.replace(/>/g, '&gt;');
      }
      R.push(text);
    }
    if (R[first_idx] != null) {
      R[first_idx] = R[first_idx].replace(/^\s+/);
    }
    return R;
  };

  this.render_open_tag = function(name, attributes) {
    return (this.render_empty_tag(name, attributes)).replace(/<\/[^>]+>$/, '');
  };

  this.render_close_tag = function(name) {
    return "</" + name + ">";
  };

  this.render_as_close_tag = function(open_tag) {
    return this.render_close_tag(open_tag.replace(/^<([^\s>]+).*$/, '$1'));
  };

  this.render_empty_tag = function(name, attributes) {
    return TEACUP.render((function(_this) {
      return function() {
        return TEACUP.TAG(name, attributes);
      };
    })(this));
  };

  this._new_hotml = function() {
    return [[], [], []];
  };

  this.slice = function(me, start, stop) {

    /* `i` for input */
    var R, i_close_tag, i_close_tags, i_list_of_close_tags, i_list_of_open_tags, i_open_tag, i_open_tags, i_texts, idx, initial_close_tags, initial_open_tags, main_idx, o_close_tags, o_list_of_close_tags, o_list_of_open_tags, o_open_tag_count, o_texts, sub_idx, tag_stack, target, _i, _j, _k, _l, _len, _len1, _m, _n, _ref, _ref1, _ref2, _ref3;
    i_list_of_open_tags = me[0], i_texts = me[1], i_list_of_close_tags = me[2];

    /* `o` for output */
    _ref = R = this._new_hotml(), o_list_of_open_tags = _ref[0], o_texts = _ref[1], o_list_of_close_tags = _ref[2];
    if (start >= stop) {
      return R;
    }
    start = Math.max(start, 0);
    stop = Math.min(stop, i_texts.length - 1);
    o_open_tag_count = 0;
    tag_stack = [];
    initial_open_tags = [];
    initial_close_tags = [];
    o_list_of_open_tags.push(initial_open_tags);
    o_texts.push('');
    o_list_of_close_tags.push(initial_close_tags);

    /* Walking backwards from `start` to the beginning, collecting closing and opening tags: */
    for (main_idx = _i = _ref1 = start - 1; _i >= 0; main_idx = _i += -1) {
      i_open_tags = i_list_of_open_tags[main_idx];
      i_close_tags = i_list_of_close_tags[main_idx];
      o_open_tag_count -= i_close_tags.length;
      for (sub_idx = _j = _ref2 = i_open_tags.length - 1; _j >= 0; sub_idx = _j += -1) {
        o_open_tag_count += 1;
        if (!(o_open_tag_count > 0)) {
          continue;
        }
        tag_stack.unshift(i_open_tags[sub_idx]);
        initial_open_tags.unshift(i_open_tags[sub_idx]);
      }
    }

    /* Walking forward through the slice: */
    for (main_idx = _k = start; _k < stop; main_idx = _k += +1) {
      i_open_tags = i_list_of_open_tags[main_idx];
      i_close_tags = i_list_of_close_tags[main_idx];
      o_close_tags = [];
      o_open_tag_count += i_open_tags.length;
      o_open_tag_count -= i_close_tags.length;
      for (_l = 0, _len = i_open_tags.length; _l < _len; _l++) {
        i_open_tag = i_open_tags[_l];
        tag_stack.push(i_open_tag);
      }
      if (main_idx === start) {
        initial_open_tags.push.apply(initial_open_tags, i_open_tags);
        o_texts[0] = i_texts[main_idx];
        initial_close_tags.push.apply(initial_close_tags, i_close_tags);
      } else {
        o_list_of_open_tags.push(CND.LODASH.clone(i_open_tags));
        o_texts.push(i_texts[main_idx]);
        o_list_of_close_tags.push(CND.LODASH.clone(i_close_tags));
      }
      for (_m = 0, _len1 = i_close_tags.length; _m < _len1; _m++) {
        i_close_tag = i_close_tags[_m];
        tag_stack.pop();
      }
    }

    /* Closing all remaining open tags: */
    if (tag_stack.length > 0) {
      target = CND.last_of(o_list_of_close_tags);
      for (idx = _n = _ref3 = tag_stack.length - 1; _ref3 <= 0 ? _n <= 0 : _n >= 0; idx = _ref3 <= 0 ? ++_n : --_n) {
        target.push(this.render_as_close_tag(tag_stack[idx]));
      }
    }
    return R;
  };

  this.parse = function(html, settings, handler) {
    var arity;
    switch (arity = arguments.length) {
      case 2:
        handler = settings;
        settings = {};
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    CND.validate_isa_function(handler);
    this._parse(html, settings, handler);
    return null;
  };

  this.$parse = function(html) {
    throw new Error("not implemented");
  };

  this._parse = function(html, settings, handler) {
    var hyphenate, hyphenation, input, _send;
    if (handler == null) {
      handler = null;
    }
    input = D.create_throughstream();
    _send = null;
    if (settings['hyphenation'] === false) {
      hyphenate = (function(_this) {
        return function(text) {
          return text;
        };
      })(this);
    } else {
      hyphenation = settings['hyphenation'] === true ? null : settings['hyphenation'];
      hyphenate = D.new_hyphenator(hyphenation);
    }
    if (handler == null) {
      handler = (function(_this) {
        return function(error, hotml) {
          if (error) {
            return _send.error(error);
          }
          return _send(hotml);
        };
      })(this);
    }
    input.pipe(D.HTML.$parse()).pipe(D.HTML.$collect_texts()).pipe((function(_this) {
      return function() {
        var Z, close_tags, last_type, open_tags, texts, _ref;
        _ref = Z = _this._new_hotml(), open_tags = _ref[0], texts = _ref[1], close_tags = _ref[2];
        last_type = null;
        return $(function(event, send) {
          var idx, tag, tail, text_part, text_parts, type, _i, _j, _len, _len1;
          _send = send;
          type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
          switch (type) {
            case 'lone-tag':
              tag = _this.render_open_tag.apply(_this, tail);
              switch (last_type) {
                case null:
                case 'close-tag':
                case 'lone-tag':
                case 'text':
                  open_tags.push([]);
                  texts.push(tag);
                  close_tags.push([]);
                  break;
                case 'open-tag':
                  texts[texts.length - 1] = tag;
                  break;
                default:
                  return handler(new Error("1 ignored event of type " + (rpr(type))));
              }
              break;
            case 'text':
              text_parts = D.break_lines(hyphenate(tail[0]));
              switch (last_type) {
                case null:
                case 'close-tag':
                case 'lone-tag':
                case 'text':
                  for (_i = 0, _len = text_parts.length; _i < _len; _i++) {
                    text_part = text_parts[_i];
                    open_tags.push([]);
                    texts.push(text_part);
                    close_tags.push([]);
                  }
                  break;
                case 'open-tag':
                  for (idx = _j = 0, _len1 = text_parts.length; _j < _len1; idx = ++_j) {
                    text_part = text_parts[idx];
                    if (idx === 0) {
                      texts[texts.length - 1] = text_part;
                    } else {
                      open_tags.push([]);
                      texts.push(text_part);
                      close_tags.push([]);
                    }
                  }
                  break;
                default:
                  return handler(new Error("1 ignored event of type " + (rpr(type))));
              }
              break;
            case 'open-tag':
              switch (last_type) {
                case null:
                case 'text':
                case 'lone-tag':
                case 'close-tag':
                  open_tags.push([_this.render_open_tag.apply(_this, tail)]);
                  texts.push('');
                  close_tags.push([]);
                  break;
                case 'open-tag':
                  (CND.last_of(open_tags)).push(_this.render_open_tag.apply(_this, tail));
                  break;
                default:
                  return handler(new Error("2 ignored event of type " + (rpr(type))));
              }
              break;
            case 'close-tag':
              switch (last_type) {
                case null:
                  throw new Error("encountered illegal HTML");
                  break;
                case 'text':
                case 'lone-tag':
                case 'close-tag':
                case 'open-tag':
                  (CND.last_of(close_tags)).push(_this.render_close_tag.apply(_this, tail));
                  break;
                default:
                  return handler(new Error("3 ignored event of type " + (rpr(type))));
              }
              break;
            case 'end':
              handler(null, Z);
              break;
            default:
              return handler(new Error("4 ignored event of type " + (rpr(type))));
          }
          last_type = type;
          return send(Z);
        });
      };
    })(this)());
    input.write(html);
    return input.end();
  };

  this.demo = function() {
    var H, html;
    H = this;
    html = "<img src='x.jpg'>lo <div id='mydiv'><em><i>arcade &amp; &#x4e00; illustration\n<b>bromance</b> cyberspace <span class='foo'></span> necessarily</i></em> completely.</div>";
    return H.parse(html, (function(_this) {
      return function(error, hotml) {
        var delta, start, stop, _i, _j, _len, _ref;
        if (error != null) {
          throw error;
        }
        _ref = [0, 3, 10];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          start = _ref[_i];
          for (delta = _j = 0; _j <= 5; delta = ++_j) {
            stop = start + delta;
            info(start, stop, H.as_html(H.slice(hotml, start, stop)));
          }
        }
        urge(JSON.stringify(hotml));
        help(H.rpr(hotml));
        return info(H.as_html(hotml));
      };
    })(this));
  };

  if (module.parent == null) {
    this.demo();
  }

}).call(this);
