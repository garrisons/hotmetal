// Generated by CoffeeScript 1.9.1
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.HTML = {};

  this.HTML.$parse = function(settings) {
    return $((function(_this) {
      return function(html, send) {
        return send(PIPEDREAMS.HOTMETAL.HTML.parse(html, settings));
      };
    })(this));
  };

  this.HTML.$split = function(settings) {
    return $((function(_this) {
      return function(html, send) {
        return send(PIPEDREAMS.HOTMETAL.HTML.split(html, settings));
      };
    })(this));
  };

  this.HTML.$slice_toplevel_tags = function() {
    return $((function(_this) {
      return function(me, send) {
        return PIPEDREAMS.HOTMETAL.slice_toplevel_tags(me, function(error, slice) {
          if (error != null) {
            return send.error(error);
          }
          return send(slice);
        });
      };
    })(this));
  };

  this.HTML.$unwrap = function(silent) {
    if (silent == null) {
      silent = false;
    }
    return $((function(_this) {
      return function(me, send) {
        return send(PIPEDREAMS.HOTMETAL.unwrap(me, silent));
      };
    })(this));
  };

  this.HTML = {};

  this.HTML._lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);

  this.HTML.parse = (function(_this) {
    return function(html, settings) {

      /* TAINT words in code blocks will be hyphenated, too */
      var R, chrs, disperse, fragmentize, fragmentize_settings, handlers, hyphenate, hyphenation, parser, ref, ref1, ref2, ref3, whitespace;
      disperse = (ref = settings != null ? settings['disperse'] : void 0) != null ? ref : true;
      hyphenation = (ref1 = settings != null ? settings['hyphenation'] : void 0) != null ? ref1 : true;
      whitespace = (ref2 = settings != null ? settings['whitespace'] : void 0) != null ? ref2 : false;
      chrs = (ref3 = settings != null ? settings['chrs'] : void 0) != null ? ref3 : false;
      fragmentize_settings = {
        whitespace: whitespace,
        chrs: chrs
      };
      if (disperse) {
        fragmentize = _this.fragmentize.bind(_this);
      } else {
        fragmentize = function(text) {
          return [text];
        };
      }
      if (hyphenation === false) {
        hyphenate = function(text) {
          return text;
        };
      } else if (CND.isa_function(hyphenation)) {
        hyphenate = hyphenation;
      } else {
        hyphenation = hyphenation === true ? null : hyphenation;
        hyphenate = _this.new_hyphenate(hyphenation);
      }
      handlers = {
        doctype: function(name, pid, sid) {
          return _this.add(R, 'doctype', name, pid, sid);
        },
        endTag: function(name) {
          return _this.add(R, 'close-tag', name);
        },
        comment: function(text) {
          return _this.add(R, 'comment', CND.escape_html(text));
        },
        text: function(text) {
          var i, len, ref4, results, text_part;
          text = CND.escape_html(text);
          text = hyphenate(text);
          ref4 = fragmentize(text, fragmentize_settings);
          results = [];
          for (i = 0, len = ref4.length; i < len; i++) {
            text_part = ref4[i];
            results.push(_this.add(R, 'text', text_part));
          }
          return results;
        },
        startTag: function(name, a) {
          var attributes, i, k, len, ref4, v;
          attributes = {};
          if (a != null) {
            for (i = 0, len = a.length; i < len; i++) {
              ref4 = a[i], k = ref4.name, v = ref4.value;
              attributes[k] = v;
            }
          }
          if (indexOf.call(_this.HTML._lone_tags, name) >= 0) {
            if (name === 'wbr') {
              if ((Object.keys(attributes)).length > 0) {
                throw new Error("illegal <wbr> tag with attributes");
              }

              /* as per https://developer.mozilla.org/en/docs/Web/HTML/Element/wbr */
              return _this.add(R, 'text', '\u200b');
            } else {
              return _this.add(R, 'lone-tag', name, attributes);
            }
          } else {
            return _this.add(R, 'open-tag', name, attributes);
          }
        }
      };
      parser = new (require('parse5')).SimpleApiParser(handlers);
      R = _this._new_hotml();
      parser.parse(html);
      return R;
    };
  })(this);

  this.HTML.split = (function(_this) {
    return function(html, settings) {

      /* A faster parse routine that returns a list whose elements alternatively represent tags and
      texts.
      
      In the returned list, elements at even indices are always single texts representing openening and closing
      tags, while the elements at odd indices are either single texts (when `disperse` was `false`) or lists
      of texts (when `disperse` was `true`) representing textual contents.
       */

      /* TAINT code duplication */
      var R, chrs, disperse, fragmentize, fragmentize_settings, handlers, hyphenate, hyphenation, last_type, parser, ref, ref1, ref2, ref3, whitespace;
      disperse = (ref = settings != null ? settings['disperse'] : void 0) != null ? ref : true;
      hyphenation = (ref1 = settings != null ? settings['hyphenation'] : void 0) != null ? ref1 : true;
      whitespace = (ref2 = settings != null ? settings['whitespace'] : void 0) != null ? ref2 : false;
      chrs = (ref3 = settings != null ? settings['chrs'] : void 0) != null ? ref3 : false;
      fragmentize_settings = {
        whitespace: whitespace,
        chrs: chrs
      };
      last_type = null;
      if (disperse) {
        fragmentize = _this.fragmentize.bind(_this);
      } else {
        fragmentize = function(text) {
          return [text];
        };
      }
      if (hyphenation === false) {
        hyphenate = function(text) {
          return text;
        };
      } else if (CND.isa_function(hyphenation)) {
        hyphenate = hyphenation;
      } else {
        hyphenation = hyphenation === true ? null : hyphenation;
        hyphenate = _this.new_hyphenate(hyphenation);
      }
      handlers = {
        doctype: function(name, pid, sid) {
          throw new Error("not implemented");
        },
        comment: function(text) {
          var tag;
          tag = "<!-- " + text + " -->";
          if (last_type === 'tag') {
            R[R.length - 1] += tag;
          } else {
            R.push(tag);
          }
          return last_type = 'tag';
        },
        endTag: function(name) {
          var tag;
          tag = _this._render_close_tag(name);
          if (last_type === 'tag') {
            R[R.length - 1] += tag;
          } else {
            R.push(tag);
          }
          return last_type = 'tag';
        },
        text: function(text) {
          var text_parts;
          if (last_type === null) {
            R.push('');
          }
          text = CND.escape_html(text);
          text = hyphenate(text);
          if (disperse) {
            text_parts = fragmentize(text, fragmentize_settings);
            if (last_type === 'text') {
              Array.prototype.push.apply(R[R.length - 1], text_parts);
            } else {
              R.push(text_parts);
            }
          } else {
            if (last_type === 'text') {
              R[R.length - 1] += text;
            } else {
              R.push(text);
            }
          }
          return last_type = 'text';
        },
        startTag: function(name, attributes) {
          var tag;
          tag = _this._render_open_tag(name, attributes);
          if (last_type === 'tag') {
            R[R.length - 1] += tag;
          } else {
            R.push(tag);
          }
          return last_type = 'tag';
        }
      };
      parser = new (require('parse5')).SimpleApiParser(handlers);
      R = [];
      parser.parse(html);
      return R;
    };
  })(this);


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

}).call(this);
