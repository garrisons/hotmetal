// Generated by CoffeeScript 1.9.1
(function() {
  var $, CND, D, HOTMETAL, badge, rpr,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'HOTMETAL/HTML';

  HOTMETAL = require('..');

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  this._lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);

  this.parse = function(html, settings) {

    /* TAINT words in code blocks will be hyphenated, too */
    var R, chrs, disperse, fragmentize, fragmentize_settings, handlers, hyphenate, hyphenation, parser, ref, ref1, ref2, ref3, whitespace;
    disperse = (ref = settings != null ? settings['disperse'] : void 0) != null ? ref : true;
    hyphenation = (ref1 = settings != null ? settings['hyphenation'] : void 0) != null ? ref1 : true;
    whitespace = (ref2 = settings != null ? settings['whitespace'] : void 0) != null ? ref2 : false;
    chrs = (ref3 = settings != null ? settings['chrs'] : void 0) != null ? ref3 : false;
    fragmentize_settings = {
      whitespace: whitespace,
      chrs: chrs
    };
    if (disperse) {
      fragmentize = HOTMETAL.LINEBREAKER.fragmentize.bind(HOTMETAL.LINEBREAKER);
    } else {
      fragmentize = function(text) {
        return [text];
      };
    }
    if (hyphenation === false) {
      hyphenate = (function(_this) {
        return function(text) {
          return text;
        };
      })(this);
    } else if (CND.isa_function(hyphenation)) {
      hyphenate = hyphenation;
    } else {
      hyphenation = hyphenation === true ? null : hyphenation;
      hyphenate = HOTMETAL.HYPHENATOR.new_hyphenate(hyphenation);
    }
    handlers = {
      doctype: (function(_this) {
        return function(name, pid, sid) {
          return HOTMETAL.add(R, 'doctype', name, pid, sid);
        };
      })(this),
      endTag: (function(_this) {
        return function(name) {
          return HOTMETAL.add(R, 'close-tag', name);
        };
      })(this),
      comment: (function(_this) {
        return function(text) {
          return HOTMETAL.add(R, 'comment', CND.escape_html(text));
        };
      })(this),
      text: (function(_this) {
        return function(text) {
          var i, len, ref4, text_part;
          text = CND.escape_html(text);
          text = hyphenate(text);
          ref4 = fragmentize(text, fragmentize_settings);
          for (i = 0, len = ref4.length; i < len; i++) {
            text_part = ref4[i];
            HOTMETAL.add(R, 'text', text_part);
          }
          return null;
        };
      })(this),
      startTag: (function(_this) {
        return function(name, a) {
          var attributes, i, k, len, ref4, v;
          attributes = {};
          if (a != null) {
            for (i = 0, len = a.length; i < len; i++) {
              ref4 = a[i], k = ref4.name, v = ref4.value;
              attributes[k] = v;
            }
          }
          if (indexOf.call(_this._lone_tags, name) >= 0) {
            if (name === 'wbr') {
              if ((Object.keys(attributes)).length > 0) {
                throw new Error("illegal <wbr> tag with attributes");
              }

              /* as per https://developer.mozilla.org/en/docs/Web/HTML/Element/wbr */
              HOTMETAL.add(R, 'text', '\u200b');
            } else {
              HOTMETAL.add(R, 'lone-tag', name, attributes);
            }
          } else {
            HOTMETAL.add(R, 'open-tag', name, attributes);
          }
          return null;
        };
      })(this)
    };
    parser = new (require('parse5')).SimpleApiParser(handlers);
    R = HOTMETAL._new_hotml();
    parser.parse(html);
    return R;
  };

  this.split = function(html, settings) {

    /* A faster parse routine that returns a list whose elements alternatively represent tags and
    texts.
    
    In the returned list, elements at even indices are always single texts representing openening and closing
    tags, while the elements at odd indices are either single texts (when `disperse` was `false`) or lists
    of texts (when `disperse` was `true`) representing textual contents.
     */

    /* TAINT code duplication */
    var R, chrs, disperse, fragmentize, fragmentize_settings, handlers, hyphenate, hyphenation, last_type, parser, ref, ref1, ref2, ref3, whitespace;
    disperse = (ref = settings != null ? settings['disperse'] : void 0) != null ? ref : true;
    hyphenation = (ref1 = settings != null ? settings['hyphenation'] : void 0) != null ? ref1 : true;
    whitespace = (ref2 = settings != null ? settings['whitespace'] : void 0) != null ? ref2 : false;
    chrs = (ref3 = settings != null ? settings['chrs'] : void 0) != null ? ref3 : false;
    fragmentize_settings = {
      whitespace: whitespace,
      chrs: chrs
    };
    last_type = null;
    if (disperse) {
      fragmentize = HOTMETAL.LINEBREAKER.fragmentize.bind(HOTMETAL.LINEBREAKER);
    } else {
      fragmentize = function(text) {
        return [text];
      };
    }
    if (hyphenation === false) {
      hyphenate = (function(_this) {
        return function(text) {
          return text;
        };
      })(this);
    } else if (CND.isa_function(hyphenation)) {
      hyphenate = hyphenation;
    } else {
      hyphenation = hyphenation === true ? null : hyphenation;
      hyphenate = HOTMETAL.HYPHENATOR.new_hyphenate(hyphenation);
    }
    handlers = {
      doctype: (function(_this) {
        return function(name, pid, sid) {
          throw new Error("not implemented");
        };
      })(this),
      comment: (function(_this) {
        return function(text) {
          var tag;
          tag = "<!-- " + text + " -->";
          if (last_type === 'tag') {
            R[R.length - 1] += tag;
          } else {
            R.push(tag);
          }
          return last_type = 'tag';
        };
      })(this),
      endTag: (function(_this) {
        return function(name) {
          var tag;
          tag = _this._render_close_tag(name);
          if (last_type === 'tag') {
            R[R.length - 1] += tag;
          } else {
            R.push(tag);
          }
          last_type = 'tag';
          return null;
        };
      })(this),
      text: (function(_this) {
        return function(text) {
          var text_parts;
          if (last_type === null) {
            R.push('');
          }
          text = CND.escape_html(text);
          text = hyphenate(text);
          if (disperse) {
            text_parts = fragmentize(text, fragmentize_settings);
            if (last_type === 'text') {
              Array.prototype.push.apply(R[R.length - 1], text_parts);
            } else {
              R.push(text_parts);
            }
          } else {
            if (last_type === 'text') {
              R[R.length - 1] += text;
            } else {
              R.push(text);
            }
          }
          last_type = 'text';
          return null;
        };
      })(this),
      startTag: (function(_this) {
        return function(name, attributes) {
          var tag;
          tag = _this._render_open_tag(name, attributes);
          if (last_type === 'tag') {
            R[R.length - 1] += tag;
          } else {
            R.push(tag);
          }
          last_type = 'tag';
          return null;
        };
      })(this)
    };
    parser = new (require('parse5')).SimpleApiParser(handlers);
    R = [];
    parser.parse(html);
    return R;
  };

  this.$parse = function(settings) {
    return $((function(_this) {
      return function(html, send) {
        return send(_this.parse(html, settings));
      };
    })(this));
  };

  this.$split = function(settings) {
    return $((function(_this) {
      return function(html, send) {
        return send(_this.split(html, settings));
      };
    })(this));
  };

  this.$slice_toplevel_tags = function() {
    return $((function(_this) {
      return function(me, send) {
        return HOTMETAL.slice_toplevel_tags(me, function(error, slice) {
          if (error != null) {
            return send.error(error);
          }
          return send(slice);
        });
      };
    })(this));
  };

  this.$unwrap = function(silent) {
    if (silent == null) {
      silent = false;
    }
    return $((function(_this) {
      return function(me, send) {
        return send(HOTMETAL.unwrap(me, silent));
      };
    })(this));
  };

}).call(this);
